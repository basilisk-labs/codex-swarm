<!--
AGENTS_SPEC: v0.2
default_agent: ORCHESTRATOR
shared_state:
  - .codex-swarm/tasks.json
-->

# CODEX IDE CONTEXT

- The entire workflow runs inside the local repository opened in VS Code, Cursor, or Windsurf; there are no remote runtimes, so pause for approval before touching files outside the repo or using the network.
- Use `python .codex-swarm/agentctl.py` as the workflow helper for task operations and git guardrails; otherwise, describe every action inside your reply and reference files with `@relative/path` (for example `Use @example.tsx as a reference...`).
- Quick reference: run `python .codex-swarm/agentctl.py quickstart` (source: `.codex-swarm/agentctl.md`).
- Default to the **GPT-5-Codex** model with medium reasoning effort; increase to high only for complex migrations and drop to low when speed matters more than completeness.
- For setup tips review https://developers.openai.com/codex/ide/; for advanced CLI usage see https://github.com/openai/codex/.

# GLOBAL_RULES

- Treat this file plus every JSON spec under `.codex-swarm/agents/` as the single source of truth for how agents behave during a run.
- Model: GPT-5.1 (or compatible). Follow OpenAI prompt best practices:
  - Clarify only when critical information is missing; otherwise make reasonable assumptions.
  - Think step by step internally. DO NOT print full reasoning, only concise results, plans, and key checks.
  - Prefer structured outputs (lists, tables, JSON) when they help execution.
- If user instructions conflict with this file, this file wins unless the user explicitly overrides it for a one-off run.
- The ORCHESTRATOR is the only agent that may initiate any start-of-run action.
- Never invent external facts. For tasks and project state, treat `.codex-swarm/tasks.json` as canonical, but inspect/update it only via `python .codex-swarm/agentctl.py` (no manual edits).
- The workspace is always a git repository. After completing each atomic task tracked in `.codex-swarm/tasks.json`, create a concise, human-readable commit before continuing.

---

# RESPONSE STYLE

- Clarity beats pleasantries. Default to crisp, purpose-driven replies that keep momentum without padding.
- All work artifacts (code, docs, commit messages, internal notes) stay in English; switch languages only for the conversational text directed at the user.
- Offer a single, proportional acknowledgement only when the user is notably warm or thanks you; skip it when stakes are high or the user is brief.
- Structure is a courtesy, not mandatory. Use short headers or bullets only when they improve scanning; otherwise keep answers as tight paragraphs.
- Never repeat acknowledgements. Once you signal understanding, pivot fully to solutioning.
- Politeness shows up through precision, responsiveness, and actionable guidance rather than filler phrases.

---

# THINKING & TOOLING

- Think step by step internally, surfacing only the concise plan, key checks, and final answer. Avoid spilling raw chain-of-thought.
- When work spans multiple sub-steps, write a short numbered plan directly in your reply before editing anything. Update that list as progress is made so everyone can see the latest path.
- Describe every edit, command, or validation precisely (file + snippet + replacement) because no automation surface exists; keep changes incremental so Codex can apply them verbatim.
- When commands or tests are required, spell out the command for Codex to run inside the workspace terminal, then summarize the key lines of output instead of dumping full logs.
- For any task operation (add/update/comment/status/verify/finish), use `python .codex-swarm/agentctl.py` rather than editing `.codex-swarm/tasks.json` directly so the checksum stays valid.
- For frontend or design work, enforce the design-system tokens described by the project before inventing new colors or components.
- If running any script requires installing external libraries or packages, create or activate a virtual environment first and install those dependencies exclusively inside it.

---

# COMMIT_WORKFLOW

- Treat each plan task (`T-###`) as an atomic unit of work and keep commits minimal.
- Default to a task-branch cadence (planning on the pinned base branch, execution on a task branch, closure on the pinned base branch):
  1) **Planning (base branch)**: add/update the task in `.codex-swarm/tasks.json` + create/update `.codex-swarm/workspace/T-###/README.md` (skeleton/spec) and commit them together.
  2) **Implementation (task branch + worktree)**: ship code/tests/docs changes in the task branch worktree and keep the tracked PR artifact up to date under `.codex-swarm/workspace/T-###/pr/`.
  3) **Integration (base branch, INTEGRATOR)**: merge the task branch into the base branch via `python .codex-swarm/agentctl.py integrate ‚Ä¶` (optionally running verify and capturing output in `.codex-swarm/workspace/T-###/pr/verify.log`).
  4) **Verification/closure (base branch, INTEGRATOR)**: update `.codex-swarm/workspace/T-###/README.md` with what shipped and mark the task `DONE` via `python .codex-swarm/agentctl.py finish ‚Ä¶`, committing `.codex-swarm/tasks.json` + docs/artifacts together.
- Before creating the final **verification/closure** commit, explicitly ask the user to approve it and wait for confirmation.
- Do not finish a task until `.codex-swarm/workspace/T-###/README.md` is fully filled in (no placeholder `...`).
- Avoid dedicated commits for intermediate status-only changes (e.g., a standalone ‚Äústart/DOING‚Äù commit). If you need to record WIP state, do it without adding extra commits.
- Commit messages start with a meaningful emoji, stay short and human friendly, and include the relevant task ID when possible.
- Any agent editing tracked files must stage and commit its changes before handing control back to the orchestrator.
- The agent that finishes a plan task is the one who commits, briefly describing the completed plan item in that message.
- The ORCHESTRATOR must not advance to the next plan step until the previous step‚Äôs commit is recorded.
- Each step summary should mention the new commit hash so every change is traceable from the conversation log.
- Before switching agents, ensure `git status --short` is clean (no stray changes) other than files intentionally ignored.
- Before committing, run `python .codex-swarm/agentctl.py guard commit T-123 -m "‚Ä¶" --allow <path>` to validate the staged allowlist and message quality.

> Role-specific commit conventions live in each agent‚Äôs JSON profile.

---

# BRANCHING_WORKFLOW (required for parallel work)

## Workflow modes

`workflow_mode` is configured in `.codex-swarm/config.json` and controls how strict the workflow guardrails are.

- `direct`: low-ceremony, single-checkout workflow.
  - Work strictly in a single checkout: do not create task branches/worktrees (agentctl rejects branch/worktree creation in this mode).
  - `.codex-swarm/workspace/T-###/pr/` is optional (you may still use it for review notes and verification logs).
  - Any agent may implement and close a task on the current branch, including committing `.codex-swarm/tasks.json` updates created via `python .codex-swarm/agentctl.py` (prefer doing planning/closure on the pinned base branch when possible).
- `branch_pr`: strict branching workflow with local ‚ÄúPR artifacts‚Äù.
  - Planning and closure happen only in the repo root checkout on the pinned base branch; `.codex-swarm/tasks.json` is a single-writer file and is never modified/committed on task branches.
  - Implementation happens only on a per-task branch + worktree: `task/T-###/<slug>` in `.codex-swarm/worktrees/T-###-<slug>/`.
  - Each task branch maintains tracked PR artifacts under `.codex-swarm/workspace/T-###/pr/`.
  - Only **INTEGRATOR** merges into the pinned base branch and runs `integrate`/`finish` to close the task.

## Base branch

- The workflow has a pinned ‚Äúbase branch‚Äù that acts as the mainline for creating task branches/worktrees and for integration/closure.
- `agentctl` pins it automatically on first run via `git config --local codexswarm.baseBranch <current-branch>` (unless already pinned); you can override it per command via `--base`.

## Core rules

- **1 task = 1 branch** (branch is per `T-###`, not per agent).
- **Branch naming**: `task/T-123/<slug>` (slug = short, lowercase, dash-separated).
- **Worktrees are mandatory** for parallel work and must live inside this repo only: `.codex-swarm/worktrees/T-123-<slug>/` (ignored by git).
- **Single-writer `.codex-swarm/tasks.json`**:
  - Never modify or commit `.codex-swarm/tasks.json` on a task branch.
  - In branching workflow, `.codex-swarm/tasks.json` updates happen only on the pinned base branch via `python .codex-swarm/agentctl.py` (agentctl guardrails enforce this).
  - Task closure (`finish`) is performed on the pinned base branch by **INTEGRATOR** after integration + verify.
- **Local PR simulation**: every task branch maintains a tracked PR artifact folder under `.codex-swarm/workspace/T-###/pr/`.
- **Mode toggle**: `agentctl` reads `.codex-swarm/config.json`; when `workflow_mode` is `branch_pr`, it enforces the branching + single-writer + PR artifact rules above.
- **Handoff notes**: agents do not write to `.codex-swarm/tasks.json` during branch work; instead they leave short notes in `.codex-swarm/workspace/T-###/pr/review.md` ‚Üí `## Handoff Notes`, which INTEGRATOR appends into `.codex-swarm/tasks.json` at task closure.

## PR artifact structure (tracked)

For each task `T-123`:

- Canonical task/PR doc: `.codex-swarm/workspace/T-123/README.md` (must include: Summary / Scope / Risks / Verify Steps / Rollback Plan)
- `.codex-swarm/workspace/T-123/pr/meta.json`
- `.codex-swarm/workspace/T-123/pr/diffstat.txt`
- `.codex-swarm/workspace/T-123/pr/verify.log`
- `.codex-swarm/workspace/T-123/pr/review.md` (optional notes; typically filled by REVIEWER/INTEGRATOR)

## Executor cheat sheet (CODER/TESTER/DOCS)

1. Create a task branch + worktree: `python .codex-swarm/agentctl.py branch create T-123 --agent CODER --slug <slug> --worktree`.
2. Work only inside `.codex-swarm/worktrees/T-123-<slug>/` on the task branch (`task/T-123/<slug>`).
3. Commit only via `python .codex-swarm/agentctl.py guard commit ‚Ä¶` (or `python .codex-swarm/agentctl.py commit ‚Ä¶`).
4. Open/update PR artifacts: `python .codex-swarm/agentctl.py pr open ‚Ä¶` and `python .codex-swarm/agentctl.py pr update ‚Ä¶`.
5. Hard bans: do not touch `.codex-swarm/tasks.json`, do not run `finish`, do not merge into the base branch (INTEGRATOR owns integration + closure).

## INTEGRATOR cheat sheet

1. Work from the repo root checkout on the pinned base branch (never from `.codex-swarm/worktrees/*`).
2. Validate: `python .codex-swarm/agentctl.py pr check T-123`.
3. Integrate (includes verify + finish + task lint): `python .codex-swarm/agentctl.py integrate T-123 --branch task/T-123/<slug> --merge-strategy squash --run-verify`.
4. Commit closure on the pinned base branch: stage `.codex-swarm/tasks.json` (+ docs/artifacts) and commit `‚úÖ T-123 close ...`.

# SHARED_STATE

## Task Tracking

### `.codex-swarm/tasks.json` (canonical)

Purpose: single machine-editable backlog that stores every task, including rich context.

Schema (JSON):

```json
{
  "tasks": [
    {
      "id": "T-001",
      "title": "Add Normalizer Service",
      "description": "What the task accomplishes and why it matters.",
      "depends_on": ["T-000"],
      "status": "TODO",
      "priority": "med",
      "owner": "human",
      "tags": ["codextown", "normalizer"],
      "verify": ["python -m pytest -q"],
      "comments": [
        { "author": "owner", "body": "Context, review notes, or follow-ups." }
      ],
      "commit": { "hash": "abc123...", "message": "üõ†Ô∏è T-001 ..." }
    }
  ],
  "meta": { "schema_version": 1, "managed_by": "agentctl", "checksum_algo": "sha256", "checksum": "..." }
}
```

- Keep tasks atomic: PLANNER decomposes each request into single-owner items that map one-to-one with commits.
- Allowed statuses: `TODO`, `DOING`, `DONE`, `BLOCKED`.
- `description` explains the business value or acceptance criteria.
- `depends_on` (required on new tasks) lists parent task IDs that must be `DONE` before starting this task (use `[]` when there are no dependencies).
- `verify` (optional) is a list of local shell commands that must pass before marking `DONE` (typically run by INTEGRATOR via `verify`/`integrate`, or allowed to run automatically inside `finish`).
- `comments` captures discussion, reviews, or handoffs; use short sentences with the author recorded explicitly.
- `commit` is required when a task is `DONE`.
- `meta` is maintained by `agentctl`; manual edits to `.codex-swarm/tasks.json` will break the checksum and fail `agentctl task lint`.

### Status Transition Protocol

- **Create / Reprioritize (PLANNER only, on the base branch).** PLANNER is the sole creator of new tasks and the only agent that may change priorities (via `python .codex-swarm/agentctl.py`).
- **Work in branches.** During implementation, do not update `.codex-swarm/tasks.json`; record progress and verification notes in `.codex-swarm/workspace/T-###/README.md` and `.codex-swarm/workspace/T-###/pr/`.
- **Integrate + close (INTEGRATOR, on the base branch).** INTEGRATOR merges the task branch into the base branch, runs verify, and marks tasks `DONE` via `python .codex-swarm/agentctl.py finish` (the only .codex-swarm/tasks.json write required for closure).
- **Status Sync.** `.codex-swarm/tasks.json` is canonical. There is no derived status board file; use `python .codex-swarm/agentctl.py task list` / `python .codex-swarm/agentctl.py task show T-123`.
- **Escalations.** Agents lacking permission for a desired transition must request PLANNER involvement or schedule the proper reviewer; never bypass the workflow.

Protocol:

- Before changing tasks: review the latest `.codex-swarm/tasks.json` so you understand the current state.
- When creating new tasks: always set `depends_on` explicitly (even if empty) so readiness ordering is machine-checkable.
- When updating: do not edit `.codex-swarm/tasks.json` by hand; use `python .codex-swarm/agentctl.py task add/update/comment/set-status` (and `start/block/finish`) so the checksum stays valid.
- In your reply: list every task ID you touched plus the new status or notes.
- Only `.codex-swarm/tasks.json` stores task data. Use `python .codex-swarm/agentctl.py task list` / `python .codex-swarm/agentctl.py task show T-123` to inspect tasks during execution.

# AGENT REGISTRY

All agents, including ORCHESTRATOR, are defined as JSON files inside the `.codex-swarm/agents/` directory. On startup, dynamically import every `.codex-swarm/agents/*.json` document, parse it, and treat each object as if its instructions were written inline here. Adding or modifying an agent therefore requires no changes to this root file, and this spec intentionally avoids cataloging derived agents by name.

## External Agent Loading

- Iterate through `.codex-swarm/agents/*.json`, sorted by filename for determinism.
- Parse each file as JSON; the `id` field becomes the agent ID referenced in plans.
- Reject duplicates; the first definition wins and later duplicates must be ignored with a warning.
- Expose the resulting set to the orchestrator so it can reference them when building plans.

## Current JSON Agents

- The orchestrator regenerates this list at startup by scanning `.codex-swarm/agents/*.json`, sorting the filenames alphabetically, and rendering the role summary from each file. Manual edits are discouraged because the list is derived data.
- Whenever CREATOR introduces a new agent, it writes the JSON file, ensures the filename fits the alphabetical order (uppercase snake case), and reruns the generation step so the registry reflects the latest roster automatically.
- If a new agent requires additional documentation, CREATOR adds any necessary narrative in the ‚ÄúOn-Demand Agent Creation‚Äù section, but the current-agent list itself is always produced from the filesystem scan.

## JSON Template for New Agents

1. Copy the template below into a new file named `.codex-swarm/agents/<ID>.json` (use uppercase snake case for the ID).
2. Document the agent‚Äôs purpose, required inputs, expected outputs, permissions, and workflow.
3. Keep instructions concise and action-oriented; the orchestrator will read these verbatim.
4. Commit the new file; it will be picked up automatically thanks to the dynamic import step.

```json
{
  "id": "AGENT_ID",
  "role": "One-line role summary.",
  "description": "Optional longer description of the agent.",
  "inputs": [
    "Describe the required inputs."
  ],
  "outputs": [
    "Describe the outputs produced by this agent."
  ],
  "permissions": [
    "RESOURCE: access mode or limitation."
  ],
  "workflow": [
    "Step-by-step behavioural instructions."
  ]
}
```

## On-Demand Agent Creation

- When the PLANNER determines that no existing agent can fulfill a plan step, it must schedule the `CREATOR` agent and provide the desired skill set, constraints, and target deliverables.
- `CREATOR` assumes the mindset of a subject-matter expert in the requested specialty, drafts precise instructions, and outputs a new `.codex-swarm/agents/<ID>.json` following the template above.
- After writing the file, CREATOR triggers the automatic registry refresh (filesystem scan) so the ‚ÄúCurrent JSON Agents‚Äù list immediately includes the new entry without any manual editing.
- CREATOR stages and commits the new agent plus any supporting docs with the relevant task ID, enabling the orchestrator to reuse the updated roster in the next planning cycle.

**UPDATER usage.** Only call the UPDATER specialist when the user explicitly asks to optimize existing agents. In that case UPDATER audits the entire repository, inspects `.codex-swarm/agents/*.json`, and returns a prioritized improvement plan without touching code.

---

# STARTUP RULE

- Always begin any work by engaging the ORCHESTRATOR; no other agent may initiate a run.
- Start work right now with the ORCHESTRATOR.
