# Recipes: Global Prompt Rules

This document defines the global prompt conventions for recipe scenarios and compiled bundles in Codex Swarm.
It applies to all agents and the IDE integration that consume recipe bundles.

## Core rules

- Treat the compiled bundle (`bundle.json`) as the single source of truth.
- Never invent missing inputs or environment values. Missing data must surface as `Pending Actions`.
- Do not execute tools implicitly; tool execution is always an explicit, user-confirmed step.
- Tools declared in the manifest are allowed by default; no extra opt-in is required.
- Do not read or write outside the allowlists defined by the recipe manifest and bundle policy.
- No network calls unless the manifest explicitly allows them (default: deny).
- Never write directly to `.codex-swarm/tasks/**` or `.codex-swarm/tasks.json`; use `agentctl` if a recipe requires task operations and the user confirms.

## Recipe layout

Each recipe lives under `.codex-swarm/recipes/<slug>/` and should include:
- `manifest.json` (required)
- `scenarios/*.md` (required)
- `scenarios/*.inputs.json` (required)
- `tools/` (optional runner scripts)
- `README.md` (optional but recommended)

Keep recipe content in English and ASCII whenever possible.

## Recipe inventory

The canonical recipe list is generated by:
```bash
python .codex-swarm/recipes.py scan --recipes-dir .codex-swarm/recipes --output docs/recipes-inventory.json
```
Commit `docs/recipes-inventory.json` and refresh it whenever manifests change.

## Global recipes bundle

The global bundle is a generated file that aggregates all recipes, scenarios, tools, and context snapshots so agents can load a single source of truth.
It is generated and **not** committed. Default location: `.codex-swarm/recipes/bundle.json`.

Build the bundle:
```bash
python .codex-swarm/recipes.py bundle build --out .codex-swarm/recipes/bundle.json
```

Read the bundle:
```bash
python .codex-swarm/recipes.py bundle show --bundle .codex-swarm/recipes/bundle.json --summary
python .codex-swarm/recipes.py bundle show --bundle .codex-swarm/recipes/bundle.json --recipe <slug>
```

Agents should load the summary for discovery and use the per-recipe view for full documentation.

Bundle format (recipes-bundle@1):
```json
{
  "bundle_version": "recipes-bundle@1",
  "generated_at": "2026-01-20T12:00:00Z",
  "recipes": [
    {
      "slug": "feature-spec-to-tasks",
      "name": "Task to roadmap",
      "summary": "...",
      "tags": ["planning"],
      "version": "0.2.0",
      "entrypoints": { "ide": {}, "cli": {} },
      "env": [],
      "requires": {},
      "safety": {},
      "tools": [],
      "tool_plan": [],
      "context": { "policy": {}, "files": [], "warnings": [] },
      "scenarios": [
        {
          "id": "from-issue",
          "title": "From issue text",
          "path": "scenarios/from-issue.md",
          "prompt_md": "...",
          "inputs_schema": {},
          "outputs": [],
          "required_agents": []
        }
      ]
    }
  ]
}
```

Notes:
- Context snapshots use each recipe's context policy and enforce limits.
- Default context mode is `inline_small`; override with `--context-mode` if needed.

## Bundle refresh

To refresh an existing bundle in place:
```bash
python .codex-swarm/recipes.py refresh --bundle .codex-swarm/.runs/<run-id>/bundle.json
```
The refresh command re-compiles the bundle using the stored `recipe.slug`, `scenario.id`, and `inputs`.
If a sibling `bundle.md` exists, it is updated automatically; use `--out-md` to write elsewhere.

## Runner environment variables

If a recipe provides a local runner, prefer standard env var names:
- `RECIPE_INPUTS_PATH` (required)
- `RECIPE_SCENARIO_ID` (optional)
- `RECIPE_RUN_ID` (optional)

Avoid legacy prefixes such as `CYBOS`.

## Recipe mini-CLI contract

If a recipe ships executable tooling, it should provide a mini-CLI that can be run directly from the recipe folder.
The mini-CLI must:
- cover all recipe actions used by agents (single `run` command is fine if only one action exists);
- provide `--help` usage text and example outputs in the recipe `README.md`;
- emit a structured response format aligned with agentctl format expectations.

Recommended output format (stdout JSON when `--json` is provided):
```json
{
  "status": "ok",
  "recipe": "slug",
  "scenario": "id",
  "run_id": "run-123",
  "artifacts": { "id": "path" },
  "warnings": [],
  "pending_actions": []
}
```
Error format (stdout JSON on failure):
```json
{
  "status": "error",
  "code": "INVALID_INPUTS",
  "message": "Describe the failure in one sentence.",
  "details": { "field": "spec_text" }
}
```
Exit codes must be non-zero for errors. Human-readable output is allowed by default, but JSON output must be stable and machine-readable.

## agentctl usage

Recipes may invoke `python .codex-swarm/agentctl.py` when the scenario/bundle explicitly requires task changes and the user confirms.
Guardrails still apply:
- follow AGENTS.md rules;
- never edit task files directly;
- report the commands and outcomes back to the ORCHESTRATOR.

## Scenario prompts

Scenario Markdown is the canonical prompt for the workflow and should include:
- Required inputs (with defaults when applicable).
- Agents or roles involved.
- Context requirements (explicit file references).
- Steps and failure handling.
- Expected outputs (path templates).

If any required input is missing, output a `Pending Actions` section listing the missing fields.

## Bundle usage

When a bundle is provided:
- Use `compiled_prompt_md` verbatim as the execution prompt.
- Respect `tool_plan` for commands, working directories, and read/write allowlists.
- Use `context.files` entries for references, inline content, or snippets.
- Surface `env_missing` and `pending_actions` before any execution.

## Inputs and templating

Recipe templates use `<var>` placeholders for `slug`, `version`, and input keys.
For path templates:
- Sanitize values (no `..`, absolute paths, or `~`).
- If a variable is missing, keep `<var>` and add a pending action.

## Context policy

Context inclusion is controlled by the manifest policy:
- `include` and `exclude` define which files are eligible.
- Size and count limits must be enforced.
- Binary files are references only (no inline content).

Never expand context beyond the declared policy.

## Tool plan

The tool plan is a declaration, not execution:
- Confirm with the user or ORCHESTRATOR before running.
- Run from the declared `cwd`.
- Write outputs only to `writes_allowlist` locations.
- Report tool outputs and artifacts back to the ORCHESTRATOR.

## Outputs and artifacts

- Use `outputs_expected` as the source of truth for deliverables.
- Report created or updated files as relative paths for easy review.
